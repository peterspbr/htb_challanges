import gmpy2
from functools import reduce

def chinese_remainder_theorem(items):
    N = reduce(lambda a, b: a*b, [item[0] for item in items])
    result = 0
    for n_i, a_i in items:
        N_i = N // n_i
        inv = gmpy2.invert(N_i, n_i)
        result += a_i * inv * N_i
    return result % N

def rsa_small_public_exponent_attack(ciphers, moduli, e):
    items = [(moduli[i], ciphers[i]) for i in range(len(ciphers))]
    x = chinese_remainder_theorem(items)
    m_e = gmpy2.iroot(x, e)[0]  # Taking the e-th root to get the original message
    return int(m_e)

def int_to_bytes(n):
    return n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')

# Example usage
if __name__ == "__main__":
    # Example ciphertexts and moduli
    ciphers = [
        11104302943014764115980183765377122155671041745928183308303496779324543712434548256863082084728588502577652261433218882793222363885521565773973057234007741921467481663213877718093326432452708953391384158343047355677141467188705680688120903926503658483389419433606447094557408457424800984067422054183235557860,
        43892340955480913825504955364865966103379995638895460427668866411166605616607623728478796928337345372827443183571729610571536978587769134152233810142631950846768443514055883157023219325905043901681187392005784184486138763736552009906401356178445712671537481634391892005441023294142311299170248551654482796289,
        7485885667516311030526639638971768588866967039095004603597876473433277020592513856842295685962504561940337976374736689800100207027697061339116227774353182672983558069905456714574061813847623301463212507358576915804727918184151967540216049419171417054355917039115106083332265175529362019083840271175618148111
    ]
    moduli = [
        103812399208329155329776395253697481607813373129732668633034654894224520379857913842927745773403509708623428218488777555924453471174767437685305112615705977604548349903441628926965819681485665227833079264839621932707658446166146409297723772205437252494618022979428293538015677757886137387564554731868740858487,
        150888551972531018619022429944270504178782392348689622130267027417410456132886952976198104277869045295804352595123494434621875793514886091016331859154758892394526201832845140245619349403694367998970174353462555711611404105856549917412359300882052095569269253089314789648258043915401825101460935578630063437887,
        71400403531118179269188411051263141621200146946055905080761251980209540803597138622664143958621120429050174820961589001236082099269286815451797236565523916418845821734257244701423880820503786275335417960880875422755084382580651885340805440681853203374825990950301733803629857391810322186401137580744004232817
    ]
    e = 5
    
    message_int = rsa_small_public_exponent_attack(ciphers, moduli, e)
    message_bytes = int_to_bytes(message_int)
    
    try:
        message_text = message_bytes.decode('utf-8')
        print(f"Recovered message: {message_text}")
    except UnicodeDecodeError:
        print("The recovered message could not be decoded as UTF-8. Here is the raw byte string:")
        print(message_bytes)
